// RotateAndZoomModel.js

let isDragging = false;
let previousPosition = { x: 0, y: 0 };
let initialDistance = null;

// Обработчики для событий мыши
const onMouseDown = (event) => {
    isDragging = true;
    previousPosition = { x: event.clientX, y: event.clientY };
};

const onMouseUp = () => {
    isDragging = false;
};

const onMouseMove = (event) => {
    if (isDragging) {
        const deltaMove = {
            x: event.clientX - previousPosition.x,
            y: event.clientY - previousPosition.y
        };

        const deltaRotationQuaternion = new THREE.Quaternion()
            .setFromEuler(new THREE.Euler(
                0,
                deltaMove.x * 0.01,
                0,
                'XYZ'
            ));

        this.quaternion.multiplyQuaternions(deltaRotationQuaternion, this.quaternion);
        this.position.y -= deltaMove.y * 0.01;

        previousPosition = { x: event.clientX, y: event.clientY };
    }
};

// Обработчики для сенсорных событий
const onTouchStart = (event) => {
    if (event.touches.length === 1) {
        isDragging = true;
        previousPosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
    } else if (event.touches.length === 2) {
        isDragging = false;
        initialDistance = Math.hypot(
            event.touches[0].clientX - event.touches[1].clientX,
            event.touches[0].clientY - event.touches[1].clientY
        );
    }
};

const onTouchMove = (event) => {
    if (isDragging && event.touches.length === 1) {
        const deltaMove = {
            x: event.touches[0].clientX - previousPosition.x,
            y: event.touches[0].clientY - previousPosition.y
        };

        const deltaRotationQuaternion = new THREE.Quaternion()
            .setFromEuler(new THREE.Euler(
                0,
                deltaMove.x * 0.01,
                0,
                'XYZ'
            ));

        this.quaternion.multiplyQuaternions(deltaRotationQuaternion, this.quaternion);
        this.position.y -= deltaMove.y * 0.01;

        previousPosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
    } else if (event.touches.length === 2) {
        const currentDistance = Math.hypot(
            event.touches[0].clientX - event.touches[1].clientX,
            event.touches[0].clientY - event.touches[1].clientY
        );

        if (initialDistance) {
            const scaleFactor = currentDistance / initialDistance;
            this.scale.multiplyScalar(scaleFactor);
        }

        initialDistance = currentDistance;
    }
};

const onTouchEnd = () => {
    isDragging = false;
    initialDistance = null;
};

const onWheel = (event) => {
    const scaleFactor = event.deltaY > 0 ? 0.9 : 1.1;
    this.scale.multiplyScalar(scaleFactor);
};

// Добавляем слушатели для мыши
window.addEventListener('mousedown', onMouseDown);
window.addEventListener('mouseup', onMouseUp);
window.addEventListener('mousemove', onMouseMove);
window.addEventListener('wheel', onWheel);

// Добавляем слушатели для сенсоров
window.addEventListener('touchstart', onTouchStart);
window.addEventListener('touchmove', onTouchMove);
window.addEventListener('touchend', onTouchEnd);

// Удаляем слушатели при удалении объекта, чтобы избежать утечек памяти
this.onBeforeDispose = () => {
    window.removeEventListener('mousedown', onMouseDown);
    window.removeEventListener('mouseup', onMouseUp);
    window.removeEventListener('mousemove', onMouseMove);
    window.removeEventListener('wheel', onWheel);

    window.removeEventListener('touchstart', onTouchStart);
    window.removeEventListener('touchmove', onTouchMove);
    window.removeEventListener('touchend', onTouchEnd);
};
